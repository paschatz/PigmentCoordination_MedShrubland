################################################################################
#                                                                              #
#   PigmentCoordination_MedShrubland                                           #
#   ---------------------------------------------------                        #
#                                                                              #
#   Author:      [Paschalis Chatzopoulos]                                      #
#   Contact:     [paschatzop@gmail.com]                                        #
#   Date:        November 2025                                                 #
#   Paper:       [Pigment disorganization in Salvia rosmarinus under drought   #
#                 and nitrogen addition in a Mediterranean shrubland]          #
#   Data DOI:    [https://doi.org/10.6084/m9.figshare.30636824.v1]             #
#   Manuscript DOI: [10.XXXX/XXXXX]                                            #
#                                                                              #
#   DESCRIPTION:                                                               #
#   This script produces the circular network visualisations for the           #
#   manuscript listed above (Figure 2). Specifically, it:                      #
#    - Loads pre-computed correlation and coupling outputs (nodes, edges,      #
#      pigment-level coupling, null-model results) from                        #
#      "data/network_data.rdata" generated by the main analysis script.        #
#    - Builds pigment–pigment correlation networks for each combination of     #
#      water treatment (Drought, Recovery) and nitrogen addition level         #
#      (0, 10, 20, 50 kg·N·ha⁻¹·yr⁻¹).                                         #
#    - Represents pairwise correlations as edges, with colour indicating the   #
#      sign (positive/negative), line type and transparency indicating         #
#      statistical significance, and width proportional to |correlation|.      #
#    - Colours nodes according to whether single-pigment coupling departs      #
#      significantly from the permutation-based null model.                    #
#    - Arranges the eight treatment × N networks in a 2 × 4 panel (rows:       #
#      Drought vs Recovery; columns: N levels) and exports the final layout    #
#      as high-resolution TIFF and PDF files for publication.                  #
#                                                                              #
################################################################################

# Load required libraries
library(igraph)
library(ggraph)
library(tidygraph)
library(patchwork)
library(tidyverse)
library(cowplot)

# Load pre-computed network objects (edges_list, pigment_df, results_list)
# from the main analysis script (02_analysis.R):
load("data/network_data.rdata")

# Setup colours for positive and negative correlations
pos <- "#2ECC71"
neg <- "#FF4040"

# Pigment shortcuts for compact node labels in the network plots
pigment.shorts <- c(
  "Neoxanthin" = "Neo",
  "Violaxanthin" = "Vio",
  "Antheraxanthin" = "Ant",
  "Lutein" = "Lut",
  "Zeaxanthin" = "Zea",
  "Chlorophyll-b" = "Chl-b",
  "Chlorophyll-a" = "Chl-a",
  "β-Carotene" = "β-Car")

# Theme for network plots (no axes or legends, framed panel)
theme.net <- theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  plot.title = element_text(size = 12, hjust = 0.5),
  legend.position = "none",
  axis.text = element_blank(),
  axis.title = element_blank(),
  plot.margin = margin(10, 10, 10, 10),
  panel.border = element_rect(color = "black", fill = NA, size = 0.5)
)

# Define a fixed order for pigments so they appear in the same position
# in the circular layout across all networks
fixed_pigment_order <- sort(unique(pigment_df$pigment))

# Prepare a list to store tidy network objects
net_tidy_list <- list()

# Unique treatment × N combinations to loop over, e.g. "Drought_0", "Recovery_20"
muestreo_un <- unique(paste(pigment_df$treatment, pigment_df$N, sep = "_"))

for (trt_load in muestreo_un) {
  
  # Extract treatment and N level from "treatment_N" label
  parts <- strsplit(trt_load, "_")[[1]]
  curr_treatment <- parts[1]
  curr_N <- parts[2]
  
  # --- STEP A: Prepare Nodes & Edges ---
  # Metadata for current treatment × N combination
  current_meta <- pigment_df %>%
    filter(
      as.character(treatment) == as.character(curr_treatment),
      as.character(N) == as.character(curr_N)
    ) %>%
    select(pigment, coup_sig, treatment, N) %>%  # Keep pigment name and significance flag
    distinct() # ensure one row per pigment
  
  # Raw nodes (id–pigment mapping) from network results
  nodes_raw <- results_list[[trt_load]]$nodes %>%
    as.data.frame() 
  
  # Annotate nodes with significance of single-pigment coupling and treatment/N
  nodes_annotated <- nodes_raw %>%
    left_join(current_meta, by = "pigment") %>%
    mutate(
      # Assign loop variables manually
      treatment = curr_treatment,
      N = curr_N,
      
      # Short label for plotting
      pigment_label = pigment.shorts[as.character(pigment)],
      
      # Node fill colour: blue if pigment coupling is significant, otherwise grey
      node_fill_color = case_when(
        coup_sig == "sig" ~ "#1f78b4",       # Significant -> Blue
        TRUE ~ "gray90"                      # Not Significant -> Gray
      )
    )
  
  # Retrieve edge list (pairwise correlations and significance)
  edges_df <- edges_list[[trt_load]]
  
  # Create a graph object (undirected) for this treatment × N combination
  temp_graph <- tbl_graph(nodes = nodes_annotated, edges = edges_df, directed = FALSE)
  
  # --- STEP B: Enhance Graph Data ---
  # Add node and edge attributes (labels, colours, sign, etc.) and sort nodes
  net_tidy <- temp_graph %>%
    activate(nodes) %>%
    mutate(
      # Full pigment name
      pigment_full = pigment, 
      # Short label for display
      pigment_label = pigment.shorts[as.character(pigment)],
      # Treatment and N level
      treatment = curr_treatment,
      N = curr_N,
      # Node fill colour depending on coupling significance
      node_fill_color = ifelse(coup_sig == "sig", "#1f78b4", "gray90")
    ) %>%
    arrange(pigment) %>% # Sort nodes so they appear in a consistent order on the circle
    activate(edges) %>%
    mutate(
      # Classify edge by correlation sign
      sign_cor = if_else(weight > 0, "pos", "neg"),
      edge_color = ifelse(sign_cor == "pos", pos, neg),
      # Non-significant edges are semi-transparent and dotted
      edge_alpha_val = if_else(sig_cor == "sig", 1, 0.5), 
      edge_linetype = if_else(sig_cor == "sig", "solid", "dotted"),
      # Use absolute correlation strength for edge width
      weight = abs(weight)
    )
  
  net_tidy_list[[trt_load]] <- net_tidy
}

# Define the layout:
# A linear layout is used and then wrapped into a circle to ensure stable
# node ordering across networks.
network_plots <- list()

for (trt_load in names(net_tidy_list)) {
  
  net_tidy <- net_tidy_list[[trt_load]]
  
  # Build panel title: "Drought - 10 kg N", etc.
  parts <- strsplit(trt_load, "_")[[1]]
  plot_title <- paste(parts[1], "-", parts[2], "kg N")
  
  # --- NETWORK PLOT ---
  p <- ggraph(net_tidy, layout = 'linear', circular = TRUE) + 
    
    # --- EDGES ---
    geom_edge_arc(
      aes(color = sign_cor,               # Edge colour according to sign
          alpha = I(edge_alpha_val),      # Transparency according to significance
          width = weight,                 # Edge width according to |correlation|
          linetype = I(edge_linetype))) + 
    
    scale_edge_width_continuous(
      range = c(0.2, 2), 
      limits = c(0, 1), 
      breaks = c(0.25, 0.5, 0.75, 1),
      name = "Correlation"
    ) +
    
    scale_edge_color_manual(
      values = c("pos" = pos, "neg" = neg), 
      labels = c("Negative", "Positive"),
      name = "Sign", guide = "none"
    ) +
    
    # --- NODES ---
    geom_node_point(
      aes(fill = I(node_fill_color), size = 0.5), # Node fill based on coupling significance
      shape = 21, color = "white", stroke = 1) +
    
    # --- LABELS ---
    # Node labels are slightly nudged outward to improve readability
    geom_node_text(
      aes(
        label = pigment_label,
        nudge_x = x * 1.2, 
        nudge_y = y * 1.2
      ),
      repel = TRUE,            # Repel labels to reduce overlaps
      segment.color = NA,
      box.padding = 0.1,
      point.padding = 0.1, 
      force = 1,
      size = 3, 
      color = "black"
    ) +
    
    # Hide legends for a clean multi-panel layout
    guides(
      edge_color = "none",
      edge_width = "none",
      edge_alpha = "none",
      fill = "none",
      size = "none",
      color = "none"
    ) +
    
    # --- THEME & COORDINATES ---
    theme_minimal() +
    coord_fixed(clip = "off", 
                xlim = c(-1.1, 1.1),
                ylim = c(-1.1, 1.1)) +
    labs(title = plot_title) +
    theme.net
  
  network_plots[[trt_load]] <- p
  
}

# Arrange plots in a matrix:
#  - Columns correspond to N levels (0, 10, 20, 50 kg N ha⁻¹ yr⁻¹)
#  - Top row: Drought; Bottom row: Recovery
desired_order <- c(
  "Drought_0", "Drought_10", "Drought_20", "Drought_50",
  "Recovery_0", "Recovery_10", "Recovery_20", "Recovery_50"
)

# Filter and sort plots according to the desired layout order
ordered_plots <- network_plots[desired_order[desired_order %in% names(network_plots)]]

# Column titles for N levels (top row only)
col_titles <- c("0 kg·N·ha-1·yr-1",
                "10 kg·N·ha-1·yr-1",
                "20 kg·N·ha-1·yr-1",
                "50 kg·N·ha-1·yr-1")

# Separate list into top (Drought) and bottom (Recovery) rows
row1_plots <- ordered_plots[1:4]
row2_plots <- ordered_plots[5:8]

# Add N-level titles to the top row panels
for(i in 1:4) {
  row1_plots[[i]] <- row1_plots[[i]] + 
    ggtitle(col_titles[i]) + 
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, margin = margin(b=10)),
      plot.margin = margin(5, 5, 5, 5) 
    )
}

# Remove titles from the bottom row (Recovery)
for(i in 1:4) {
  row2_plots[[i]] <- row2_plots[[i]] + 
    labs(title = NULL) + 
    theme(plot.margin = margin(5, 5, 5, 5))
}

# Function to create a vertical label ("Drought" / "Recovery") in the first column
create_row_label <- function(label_text) {
  ggplot() + 
    annotate("text", 
             x = 1, 
             y = 0.5, 
             label = label_text, 
             angle = 90, 
             size = 6, 
             color = "black",
             hjust = 0.5) +
    theme_void() +
    coord_cartesian(xlim = c(0, 1), ylim = c(0, 1), clip = "off") + 
    theme(plot.margin = margin(t = 0, r = 14, b = 0, l = 0))
}

label_drought <- create_row_label("Drought")
label_recov   <- create_row_label("Recovery")

# Build the first row (Drought + four networks)
row1_combined <- label_drought + wrap_plots(row1_plots, nrow = 1) + 
  plot_layout(widths = c(0.5, 30)) 

# Build the second row (Recovery + four networks)
row2_combined <- label_recov + wrap_plots(row2_plots, nrow = 1) + 
  plot_layout(widths = c(0.5, 30))

# Combine both rows into the final Figure 2 layout
figure3 <- (row1_combined / row2_combined) +
  plot_layout(guides = "collect") 

# Display the figure
print(figure3)

# Export final network figure:
ggsave("exports/figures/Figure3.tiff", figure3, width = 16, height = 10, dpi = 1200)
ggsave("exports/figures/Figure3.pdf", figure3, width = 16, height = 10, dpi = 1200, device = cairo_pdf)
